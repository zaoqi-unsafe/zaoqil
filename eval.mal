;;  Copyright (C) 2017  Zaoqi

;;  This program is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU Affero General Public License as published
;;  by the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.

;;  This program is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU Affero General Public License for more details.

;;  You should have received a copy of the GNU Affero General Public License
;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.

(defmacro! and
  (fn* (& xs)
       (if (empty? xs)
           true
           (if (= 1 (count xs))
               (first xs)
               (let* (condvar (gensym))
                 `(let* (~condvar ~(first xs))
                    (if ~condvar (and ~@(rest xs)) ~condvar)))))))

(defmacro! or
  (fn* (& xs)
       (if (empty? xs)
           nil
           (if (= 1 (count xs))
               (first xs)
               (let* (condvar (gensym))
                 `(let* (~condvar ~(first xs))
                    (if ~condvar ~condvar (or ~@(rest xs)))))))))

(def! displayln println)
(def! append concat)
(def! hash hash-map)
(def! hasheq hash-map)
(def! hasheqv hash-map)
(def! hash-set assoc)
(def! set list)
(def! seteq list)
(def! seteqv list)
(def! eq? =)
(def! eqv? =)
(def! equal? =)
(def! load load-file)

(defmacro! set!
  (fn* (& xs)
       (cons 'def! xs)))
(defmacro! λ
  (fn* (args & body)
       `(fn* ~args (do ~@body))))
(defmacro! begin
  (fn* (& xs)
       (cons 'do xs)))

(defmacro! define
  (fn* (& xs)
       (let* (s (first xs))
         (if (symbol? s)
             (list 'def! s (first (rest xs)))
             `(def! ~(first s) (fn* ~(rest s) ~(first (rest xs))))))))

(define (cm s xs c)
  (if (empty? xs)
      ()
      (let* (x (first xs))
        (cons
         (list c (symbol (str s '- (if (vector? x) (nth x 0) x))))
         (cm s (rest xs) (+ c 1))))))

(defmacro! provide
  (fn* (& xs) nil))

(defmacro! struct
  (fn* (id rfs)
       (let* (fs (cm id rfs 1) isit (symbol (str id "?")) ss (map (fn* (x) (nth x 1)) fs))
         (concat
          `(do
               (def! ~id
                 (fn* ~ss
                      (vector (quote ~id) ~@(map (λ (x) (list 'atom x)) ss))))
             (def! ~isit
               (fn* (s)
                    (and (vector? s) (= (count s) ~(+ (count fs) 1)) (= (nth s 0) (quote ~id))))))
          (map (fn* (x)
                    `(def! ~(symbol (str "set-" (nth x 1) "!"))
                       (fn* (s v)
                            (if (~isit s)
                                (reset! (nth s ~(nth x 0)) v)
                                (throw "type error")))))
               fs)
          (map (fn* (x)
                    `(def! ~(nth x 1)
                       (fn* (s)
                            (if (~isit s)
                                (deref (nth s ~(nth x 0)))
                                (throw "type error")))))
               fs)))))

(define clist? list?)
(struct pair (a d))
(define scons pair)
(define (car x)
  (if (pair? x)
      (pair-a x)
      (first x)))
(define (cdr x)
  (if (pair? x)
      (pair-d x)
      (rest x)))
(define null? empty?)
(define (list? xs)
  (or (clist? xs) (null? xs)
      (and (pair? xs) (list? (cdr xs)))))

(defmacro! scheme
  (fn* (& xs)
       `(let* (cons scons)
          ~(cons 'do xs))))

(define (set-member? xs x)
  (if (null? xs)
      false
      (or (= (car xs) x) (set-member? (cdr xs) x))))

(define (hash-has-key? h k)
  (set-member? (keys h) k))

(def! hash-ref
  (fn* (h k & xs)
       (if (hash-has-key? h k)
           (get h k)
           (if (clist? xs)
               (first xs)
               (throw "hash-ref: no value found for key")))))

(defmacro! let
  (fn* (ps & cs)
       `((fn* ~(map first ps)
              (do ~@cs))
         ~@(map (fn* (x) (first (rest x))) ps))))

(struct deljustv (v))
(struct del/namev (v))
(struct delv ([v #:mutable]))
(struct del+v ([v #:mutable]))
(defmacro! delay/name (fn* (x) `(del/namev (fn* () ~x))))
(define (force/name x) ((del/namev-v x)))
(defmacro! delay (fn* (x) `(delv (delay/name ~x))))
(define (force/ x)
  (let ([v (delv-v x)])
    (if (deljustv? v)
        (deljustv-v v)
        (let ([v1 (force/name v)])
          (set-delv-v! x (deljustv v1))
          v1))))
(define (%2delay+ x)
  (if (delv? x)
      (delay/name (%2delay+ (force/ x)))
      x))
(define (2delay+ x)
  (del+v (%2delay+ x)))
(define (force+ x)
  (let ([v (del+v-v x)])
    (if (del/namev? v)
        (let ([v1 (force/name v)])
          (set-del+v-v! x v1)
          x)
        v)))
(define (force x)
  (if (del/namev? x) (force/name x)
      (if (delv? x) (force/ x)
          (if (del+v? x) (force+ x)
              x))))

nil
;;  Copyright (C) 2017  Zaoqi

;;  This program is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU Affero General Public License as published
;;  by the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.

;;  This program is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU Affero General Public License for more details.

;;  You should have received a copy of the GNU Affero General Public License
;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.

(defmacro! unlazy*
  (fn* (xvs e)
       (if (null? xvs)
           e
           (let ([xv (car xvs)])
             `(unlazy ~(car (cdr xs)) (λ (~(car xv)) (unlazy* ~(cdr xvs) ~e)))))))

(defmacro! λprimitive
  (fn* (env args body)
       `(eprimitive
         (λ (~env args0)
           (unlazy-list
            args0
            (λ (~args)
              ~body))))))

(defmacro! define-primitive
  (fn* (fs body)
       `(global-env-define
         (quote ~(car fs))
         (λprimitive ~(car (cdr fs)) ~(car (cdr (cdr fs))) ~body))))

(defmacro! define-primitive-f
  (fn* (fs e)
       `(global-env-define
         (quote ~(car fs))
         (eeval
          global-env
          ~(%define-primitive-f (cdr fs) (cdr fs) e)))))

(define (%define-primitive-f sx xs e)
  (if (null? sx)
      `(list (λprimitive
              env
              args
              (unify xs args
                     (let ~(map (λ (x) [x `(eeval env ~x)]) xs)
                       ~e))) ~@xs)
      `(list 'λ (quote ~(car sx)) ~(%define-primitive-f (cdr sx) xs e))))

(defmacro! unify
  (fn* (vs xs e)
       (if (null? vs)
           e
           `(let ([~(car vs) (car ~xs)])
              (unify ~(cdr vs) (cdr ~xs) ~e)))))

(defmacro! define-primitive-f-unlazy
  (fn* (fxs e)
       `(define-primitive-f ~fxs
          (unlazy* ~(map (λ (x) (list x x)) (rest fxs)) ~e))))

(defmacro! prim
  (fn* (l)
       `(define-primitive-f-unlazy ~l ~l)))

(define (readfile f) (read-string (slurp f)))

(scheme

 ;;  Copyright (C) 2017  Zaoqi

;;  This program is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU Affero General Public License as published
;;  by the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.

;;  This program is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU Affero General Public License for more details.

;;  You should have received a copy of the GNU Affero General Public License
;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.

; Env → Symbol → Any → Env
(define env-set hash-set)

; Env → Symbol → Any
(define env-ref hash-ref)

; Env = Hash Symbol Any

; Symbol → Exp → Env → Func
(struct func (arg body env))

; Func → Func...
(struct func... (v))

; Env → Exp → DelayE
(struct delaye ([env #:mutable] exp))

; U Any DelayE → DelayE+
(struct delaye+ ([v #:mutable]))

(define (forcee x)
  (let ([v (delaye+-v x)])
    (if (delaye? v)
        (let ([v1 (eeval (delaye-env v) (delaye-exp v))])
          (set-delaye+-v! x v1)
          v1)
        v)))

; Func → Macro
(struct macro (v))

; (Env → Exp → b) → Primitive
(struct eprimitive (v))

(define (eeval env code) (delay (%eval env code)))

(define rlist-nil (λ (rs) rs))
(define (rlist-cons x xs) (λ (rs) (xs (cons x rs))))
(define (run-rlist xs) (xs '()))

(define (force+ x)
  (if (promise? x)
      (force+ (force x))
      x))

(define (unlazy-list xs f)
  (let loop ([xs xs] [rs rlist-nil])
    (cond
      [(promise? xs) (delay (unlazy-list (force xs) f))]
      [(null? xs) (f (run-rlist rs))]
      [else (loop (cdr xs) (rlist-cons (car xs) rs))])))

(define (unlazy x f)
  (if (promise? x)
      (delay (unlazy (force x) f))
      (f x)))

(define (lazymap f xs)
  (unlazy
   xs
   (λ (xs)
     (if (null? xs)
         '()
         (cons (f (car xs)) (lazymap f (cdr xs)))))))

(define (eapply env f args)
  (delay
    (unlazy
     f
     (λ (f)
       (cond
         [(eprimitive? f) ((eprimitive-v f) env args)]
         [(macro? f) (eeval (eapply env (macro-v f) (lazymap (λ (x) (list 'quote x)) args)))]
         [(func...? f) (eapply env (func...-v f) (list (cons 'list args)))]
         [else
          (let ([arg (func-arg f)] [body (func-body f)] [e (func-env f)])
            (unlazy args
                    (λ (as)
                      (let ([v (eeval
                                (env-set e arg (eeval env (car as)))
                                body)])
                        (unlazy (cdr as)
                                (λ (d)
                                  (if (null? d)
                                      v
                                      (eapply env v d))))))))])))))

(define (%eval env code)
  (unlazy
   code
   (λ (e)
     (cond
       [(symbol? e)
        (let ([x (env-ref env e)])
          (cond
            [(delaye+? x) (forcee x)]
            [else x]))]
       [(pair? e) (eapply env (%eval env (car e)) (cdr e))]
       [(delaye+? e) (forcee e)]
       [else e]))))

(define global-env (hasheq))

(define (global-env-define s x)
  (set! global-env (env-set global-env s x)))

(define-primitive (quote env args)
  (car args))

(define-primitive (list env args)
  (map (λ (x) (eeval env x)) args))

(define (mp xs)
  (let loop ([xs xs] [ps '()])
    (if (null? xs)
        ps
        (unlazy
         (car xs)
         (λ (s)
           (loop (cddr xs) (cons (cons s (cadr xs)) ps)))))))

(define self '_<)

; Env → [(Symbol,Exp)] → Env
(define (%mkenv env ps)
  (if (null? ps)
      env
      (let ([p (car ps)])
        (%mkenv (env-set env (car p) (delaye+ (delaye 0 (cdr p)))) (cdr ps)))))
(define (mkenv env ps)
  (let ([e (env-set (%mkenv env ps) self (delaye+ (void)))])
    (for ([p ps])
      (set-delaye-env! (delaye+-v (env-ref e (car p))) e))
    e))

; Set Symbol → Env → Record
(struct record (ss env))

(define-primitive (λ env args)
  (func (car args) (cadr args) env))

(define-primitive (λ... env args)
  (func... (func (car args) (cadr args) env)))

(define-primitive (record env args)
  (let ([ps (mp args)])
    (let ([ss (list->seteq (map car ps))] [e (mkenv env ps)])
      (let ([r (record ss e)])
        (set-delaye+-v! (env-ref e self) r)
        r))))

(define record-hide (seteq self))

; Env → Record → Env
(define (open env rv)
  (let ([re (record-env rv)] [ss (set->list (record-ss rv))])
    (let loop ([e env] [ss ss])
      (if (null? ss)
          e
          (let ([s (car ss)])
            (if (set-member? record-hide s)
                (loop e (cdr ss))
                (loop (env-set e s (eeval re s)) (cdr ss))))))))

(define-primitive (open env args)
  (let ([r (car args)] [exp (second args)])
    (unlazy
     (eeval env r)
     (λ (rv)
       (eeval (open env rv) exp)))))

(define-primitive (macro env args)
  (macro (eeval env (car args))))

(define-primitive (: env args)
  (let ([r (car args)])
    (unlazy* ([s (second args)] [rv (eeval env r)])
             (let ([re (record-env rv)] [ss (record-ss rv)])
               (if (set-member? ss s)
                   (eeval re s)
                   (error "undefined"))))))

(define-primitive (eval env args)
  (eeval env (eeval env (car args))))

(define-primitive (car env args)
  (unlazy* ([p (eeval env (car args))])
           (car p)))

(define-primitive (cdr env args)
  (unlazy* ([p (eeval env (car args))])
           (cdr p)))

(define-primitive-f (cons a d) (cons a d))

(define (cload f)
  (set!
   global-env
   (open
    global-env
    (ceval (readfile f)))))

(define (force* x)
  (let ([v (force+ x)])
    (cond
      [(pair? v) (cons (force* (car v)) (force* (cdr v)))]
      [else v])))

(define (ceval x) (force* (eeval global-env x)))

(global-env-define 't true)
(global-env-define 'f false)
(define-primitive-f (if b x y) (unlazy* ([b b]) (if b x y)))
(prim (boolean? x))
(prim (null? x))
(prim (char? x))
(prim (pair? x))
(prim (symbol? x))
(prim (record? x))
(prim (+ x y))
(prim (- x y))
(prim (* x y))
(prim (/ x y))
(prim (not x))
(prim (< x y))
(prim (> x y))
(prim (>= x y))
(define-primitive-f-unlazy (=< x y) (<= x y))
(define-primitive-f-unlazy (= x y) (equal? x y))

(cload "prelude.core")
)